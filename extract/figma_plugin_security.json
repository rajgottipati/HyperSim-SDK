{"extracted_information": "Figma's plugin system aims for security, stability, and performance. It evolved through several attempts to safely execute third-party code within a browser-based design tool.", "specifications": {}, "pricing": {}, "features": [], "statistics": {}, "temporal_info": {"article_date": "August 22, 2019"}, "geographical_data": {}, "plugin_security_architecture": {"overall_goal": "Run plugins with security, stability, and performance, avoiding direct `eval(PLUGIN_CODE)`.", "core_problem_identified": "JavaScript's danger lies in its access to input/output (Browser APIs) and global variables.", "final_architecture": {"document_manipulation_component": {"isolation_technique": "Realms shim sandbox", "execution_environment": "Main thread", "security_mechanism": "Whitelisting access to global values using `Proxy` objects and the `with` statement. Access to necessary JavaScript globals (e.g., `Object`) is provided by instantiating a new copy from a same-origin iframe (which doesn't act as a sandbox itself).", "api_security_pattern": "Membrane pattern (low-level `LowLevelJavascriptVm` interface) to prevent direct access to objects outside the sandbox and audit API interactions. This small, audited interface abstracts the underlying sandboxing mechanism, allowing for potential interchangeability with other solutions like a WebAssembly interpreter.", "benefits": "Direct document editing (no copy overhead), runs complex logic, synchronous API calls, intuitive coding."}, "user_interface_and_network_component": {"isolation_technique": "Null-origin `<iframe>`", "execution_environment": "Separate `<iframe>` (rendered as a modal within Figma editor)", "security_mechanism": "Browser's built-in `<iframe>` security, which restricts communication to message-passing, and null-origin prevents direct access to figma.com resources via CORS.", "purpose": "Provides a safe environment for plugins to create UI and make network requests using standard browser APIs, which are too broad to expose safely via the Realms sandbox."}, "inter_component_communication": "Message passing between the Realms sandbox (document manipulation) and the null-origin `<iframe>` (UI/network)."}}, "iframe_sandboxing": {"attempt_1_approach": {"technique": "Initial implementation used `<iframe>` tag to embed plugin code.", "security_guarantees": "When an `<iframe>` has a different origin than its container, browsers heavily restrict communication to message-passing (plain strings). `<iframe>`s can be run with a null origin to prevent cross-origin requests to figma.com via CORS. Security is guaranteed by browser vendors (years of vulnerability patching).", "api_design": "`figma.loadScene()` to get a copy of the document (asynchronous), `figma.updateScene()` to flush changes back (asynchronous).", "identified_problems": [{"problem": "Async/await user-friendliness", "details": "Message-passing is fundamentally asynchronous, requiring `async/await` throughout plugin code. This was deemed too complex and non-intuitive for many plugin developers (designers without formal CS education). Complex logic requiring multiple updates would lead to cumbersome `await loadScene()/await updateScene()` cycles."}, {"problem": "Expensive scene copying", "details": "Large Figma documents resulted in significant serialization time (e.g., 14 seconds for Microsoft's design systems file) before a plugin could even run, making quick actions unusable. Incremental or lazy loading was not feasible without months of core product re-architecture."}]}, "reintroduction_for_ui_component": {"purpose": "After initial failure as a primary plugin sandbox, null-origin `<iframe>`s were re-adopted to provide a secure environment for plugin UIs and network access, separated from the core document manipulation logic."}}, "plugin_isolation_techniques": [{"technique": "Isolated `<iframe>` (Attempt #1)", "details": "Embedding plugin code within a new `<iframe>` with a different (or null) origin. Communication is limited to explicit message passing, preventing direct DOM/application access due to browser same-origin policy. Security relies on browser-level sandboxing."}, {"technique": "WebAssembly JavaScript Interpreter (Attempt #2 - considered, not adopted)", "details": "Compiling a lightweight JavaScript interpreter (e.g., Duktape) written in C++ to WebAssembly. Plugin code is run within this interpreter's `eval` function. Isolation is achieved because the interpreter does not support browser APIs, and WebAssembly itself is a sandboxed environment without direct browser API access. Communication with the host environment is only through explicitly whitelisted APIs."}, {"technique": "Realms Shim (Attempt #3 - adopted for document manipulation)", "details": "Uses JavaScript features like the `with` statement and `Proxy` objects to create a controlled scope for plugin execution. Variable lookups are resolved against a `scopeProxy` that only exposes whitelisted properties, effectively hiding global variables and browser APIs. A same-origin `<iframe>` is used to provide a clean copy of JavaScript intrinsics (e.g., `Object`) without exposing the main window's globals."}], "secure_plugin_system_design_patterns": [{"pattern": "Whitelist-based Security", "details": "Instead of blacklisting known dangerous operations, the system employs whitelisting, where plugins only have access to explicitly granted APIs and resources. Both the WebAssembly interpreter and Realms approaches inherently support this, ensuring a smaller, auditable attack surface."}, {"pattern": "Membrane Pattern", "details": "A low-level, small, and carefully audited interface (`LowLevelJavascriptVm`) is established between the host application (Figma) and the plugin's execution environment (Realms sandbox). This interface handles the explicit copying of data (integers, strings, opaque handles) in and out, preventing direct object references across the security boundary. This separates API implementation details from core security concerns."}, {"pattern": "Separation of Concerns (Document vs. UI/Network)", "details": "Plugins are architecturally split into two parts: one for secure document manipulation (running in the Realms sandbox on the main thread) and another for user interface and network interactions (running in a null-origin `<iframe>`). This compartmentalizes different security risks and leverages the most appropriate sandboxing technique for each type of functionality."}, {"pattern": "Fallback/Interchangeable Implementation", "details": "The membrane pattern and `LowLevelJavascriptVm` interface allow for the underlying sandbox implementation to be swapped (e.g., from Realms to a WebAssembly interpreter) without breaking existing APIs or requiring reimplementation, providing a robust backup plan in case of security vulnerabilities in one sandbox technology."}]}