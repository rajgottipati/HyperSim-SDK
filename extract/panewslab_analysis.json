{"extracted_information": "Hyperliquid utilizes a dual-chain architecture comprising Hyperliquid L1 (permissioned, for order book) and HyperEVM (permissionless, EVM-compatible for smart contracts), interacting via precompiles and events. The system employs HyperBFT consensus for high-speed transaction processing. Technical considerations include msg.sender handling, non-atomicity, L1 mapping accounts, and asset balance visibility issues.", "specifications": {"validator_nodes": {"total": 4, "hotValidatorSet": 4, "coldValidatorSet": 4, "lockers": {"addresses": 5, "votes_to_suspend": 2}, "finalizers": "special group of validators, often same as hotValidatorSet"}, "bridge_dispute_period": {"duration": "200 seconds"}, "consensus_protocol": {"name": "HyperBFT", "basis": "HotStuff (HotStuff-2 derivative)", "previous_protocol_tendermint_performance": "up to 20,000 orders per second (O(nÂ²) communication complexity)", "hyperbft_theoretical_performance": "up to 2 million orders per second", "implementation_language": "Rust"}, "precompile_addresses": {"ecRecover_native_evm": "0x01", "hyperliquid_known_precompile": "0x0000000000000000000000000000000000000000800"}, "validator_set_update_dispute_period": "200 seconds"}, "pricing": {}, "features": [{"name": "HyperEVM Core Capabilities", "description": "Enables order book transactions to be programmable. Can read HyperLiquid order book status and smart contracts within HyperEVM can interact with the Hyperliquid order book system, expanding application scenarios (e.g., privacy layers for order placement)."}, {"name": "Dual-Chain Architecture (HyperL1 & HyperEVM)", "description": "Hyperliquid nodes run two blockchains simultaneously. Hyperliquid L1 is a permissioned chain for the customized order book system. HyperEVM is an EVM-compatible, permissionless chain where anyone can deploy contracts. Both chain's data propagate via the same consensus protocol (HyperBFT) as a unified state, but run in separate execution environments. HyperL1 block generation is faster than HyperEVM, but blocks are executed sequentially. EVM contracts can read past L1 blocks and write to future L1 blocks."}, {"name": "Precompiles Functionality", "description": "Moves complex/high-complexity operations from smart contracts directly to the underlying layer (e.g., C/C++) for efficiency. Allows EVM to support advanced functions. Acts as special smart contracts that others can call. HyperEVM uses precompiles to read Hyperliquid order book status, specifically `0x800` to read user's perpetual contract position in L1."}, {"name": "Events Interaction", "description": "Utilizes native EVM 'Events' for smart contracts to send log information externally, monitoring operations and passing cross-chain parameters. HyperLiquid nodes listen to specific HyperEVM events (e.g., `IocOrder` from `0x3...`) to convert them into order operations in HyperL1."}, {"name": "HyperBFT Consensus Protocol", "description": "A derivative of HotStuff, designed for high throughput. Leader-based block production where nodes vote, and results are summarized and broadcasted by the leader, reducing communication complexity compared to Tendermint."}, {"name": "Bridge Security Mechanisms", "description": "Validator sets (hotValidatorSet, coldValidatorSet, finalizers, lockers) with distinct roles and signature weights for deposits, withdrawals, and system configuration changes. Includes a 'dispute period' for withdrawals allowing validation and potential invalidation by coldValidatorSet or suspension by lockers."}], "statistics": {"hyperliquid_tvl_usd": "2 billion", "hyperliquid_fdv_usd_within_1_month": "30 billion"}, "temporal_info": {"article_publication_date": "01/08/2025"}, "geographical_data": {}, "references": ["Hyperliquid: The Hyperoptimized Order Book L1", "hyperliquid-dex/contracts", "The Not-So-Definitive guide to Hyperliquid Precompiles.", "What is the difference between PBFT, Tendermint, HotStuff, and HotStuff-2?"], "technical_implementation_details": {"developer_considerations": {"msg_sender_problem": "When users interact via L1 system contract, msg.sender in HyperEVM smart contract will be L1 system contract address, not original user address.", "non_atomicity_of_interaction": "Transactions initiated on HyperEVM to L1 (e.g., order placement) may fail in L1 due to insufficient assets without an error return prompt on the EVM side. Requires manual failure handling and fund recovery functions in EVM smart contracts.", "mapping_account_in_l1": "EVM contract addresses require a mapping account in L1; a small USDC transfer to the L1 mapping address is needed post-deployment to force L1 account creation.", "token_balance_issues": "Assets transferred from L1 to HyperEVM via a special L1 address may not immediately reflect on HyperEVM if blocks aren't produced for a long time, making assets appear stuck (neither in L1 nor EVM)."}}}