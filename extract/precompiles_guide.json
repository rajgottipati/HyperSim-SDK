{"extracted_information": "The document provides a detailed, albeit 'not-so-definitive', guide to Hyperliquid Precompiles, explaining their integration between the Hyperliquid L1 and HyperEVM. Precompiles enable smart contracts on HyperEVM to access the state of the Hyperliquid L1, specifically its perps and spot liquidity.", "specifications": {"precompile_address_example": "0x0000000000000000000000000000000000000800", "event_system_address": "0x3333333333333333333333333333333333333333", "erc20_transfer_system_address": "0x2222222222222222222222222222222222222222", "hyperliquid_stack": "Consists of two chains: Hyperliquid L1 (permissioned, native components like order books, high performance, API programmable) and HyperEVM (general-purpose EVM compatible, permissionless, access to L1 liquidity). Both operate as separate execution environments under one unified state and consensus.", "block_execution": "L1 produces faster blocks than EVM. EVM can read L1 state from the previous block and write to the next L1 block. Blocks are executed sequentially."}, "pricing": {}, "features": [{"name": "Precompiled Contracts (Precompiles)", "description": "Offer a way for an EVM implementation to provide access to native functions. They behave like smart contracts with a well-known address, but their internal execution is determined by the EVM implementation. They primarily allow reading state from the L1.", "implementation_details": "Calling a precompile involves a `staticcall` to its address. Example: `PRECOMPILE_ADDRESS.staticcall(abi.encode(user, perp))` to read a user's perp positions. Guarantees that the value read will be up-to-date due to sequential block execution."}, {"name": "Events", "description": "Used to perform actions on the L1 from HyperEVM smart contracts. Events emitted from a specific system address are transformed into transactions executed on the L1.", "implementation_details": "Events must be emitted from the `0x3333333333333333333333333333333333333333` system address to be converted into L1 actions. Any contract can embed functionality to read from a Precompile, but actions require emitting events from this specific address."}, {"name": "ERC20 Transfers to L1", "description": "Tokens can be sent from the EVM to the L1 via an ERC20 transfer to a specific system address.", "implementation_details": "Transfer to `0x2222222222222222222222222222222222222222`. Once transferred, the amount is credited to the L1 spot balance. The balance enters a 'pre-crediting state' not immediately visible via `ERC20().balanceOf()` or L1 state reads in the same EVM block."}], "statistics": {}, "temporal_info": {"proof_of_concept_status": "The techniques discussed are still only available as a proof of concept on Testnet and may change in the future."}, "geographical_data": {}, "references": [], "limitations": [{"name": "Partial Atomicity", "description": "When interacting with the L1 via the event system, only partial atomicity exists. Atomicity is guaranteed for the event emission itself (i.e., if an EVM transaction reverts, the event is not emitted). However, the L1 action signaled by the event does not execute within the EVM block and is not atomic with the EVM transaction. If an L1 action fails (e.g., insufficient margin), the EVM transaction (and its state updates) is not rolled back.", "implications": "No direct response or response data from L1 actions. Updated L1 state via Precompiles is only available in subsequent EVM blocks."}, {"name": "Message Sender vs. Transaction Origin", "description": "L1 actions initiated via the system contract (`0x333...333`) are executed in the context of the `msg.sender` (the smart contract), not the transaction origin (the user).", "implications": "The smart contract is performing the action on L1. Developers must ensure recovery mechanisms for funds if a contract performs L1 interactions (e.g., closing orders)."}, {"name": "L1 Account Existence", "description": "When a new smart contract interacts with the L1 for the first time, the L1 action will silently fail if the smart contract's address does not already exist as an account on the L1.", "workaround": "A dust amount of USDC must be manually sent from any L1 account to the smart contract's address on the L1 to force account creation."}, {"name": "Missing Transfer Tracking", "description": "After an ERC20 transfer from EVM to L1 system address, the transferred amount is not immediately reflected in `ERC20().balanceOf()` on EVM or in L1 spot balance reads via Precompiles within the same block.", "implications": "Protocols needing a total balance across EVM and L1 must internally track this 'pre-crediting state' for outgoing ERC20 transfers."}]}