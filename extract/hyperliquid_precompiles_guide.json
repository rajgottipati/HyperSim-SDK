{"raw_content": "{\n  \"data\": {\n    \"extracted_information\": \"Hyperliquid Precompiles refer to the integration between the Hyperliquid L1 (a permissioned chain running native components like perps and spot order books, designed for high performance) and the HyperEVM (a general-purpose, permissionless, EVM-compatible chain). These two chains exist as a unified state under the same consensus but operate as separate execution environments. The L1 produces faster block times, and blocks are executed sequentially, allowing the EVM to read L1 state from the previous block and write actions for the next L1 block. This native integration is achieved through two primary techniques: Precompiles and Events.\\n\\n**Precompiles (for Reading L1 State):**\\nPrecompiled contracts, or Precompiles, offer a way for an EVM implementation to provide access to native functions. They behave like smart contracts with a well-known address, but their internal execution is specific to the EVM implementation. Their primary use is to allow smart contracts on the HyperEVM to read the current state of the L1. For example, a contract can read a user's perp positions on the L1 using a `staticcall` to a specific precompile address. Due to the sequential execution, the value read is guaranteed to be up-to-date.\\n\\nExample for reading a user's perp position (Solidity):\\nsolidity\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\ncontract PositionReader {\\n    address constant PRECOMPILE_ADDRESS = 0x0000000000000000000000000000000000000800;\\n    struct Position {\\n        int64 szi;\\n        uint32 leverage;\\n        uint64 entryNtl;\\n    }\\n    function readPosition(address user, uint16 perp) external view returns (Position memory) {\\n        (bool success, bytes memory result) = PRECOMPILE_ADDRESS.staticcall(abi.encode(user, perp));\\n        require(success, \\\"readPosition call failed\\\");\\n        return abi.decode(result, (Position));\\n    }\\n}\\n\\n\\n**Events (for Performing L1 Actions):**\\nEvents are used when a smart contract wants to perform an action on the L1. The Hyperliquid execution environment transforms events emitted from a specific system address (`0x3333333333333333333333333333333333333333`) into transactions that are executed on the L1. While any contract can embed functionality to read from a precompile address, events for L1 actions must be emitted from this designated system address.\\n\\nExample for sending an L1 order (Solidity):\\nsolidity\\n// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\ncontract L1Write {\\n    event IocOrder(address indexed user, uint16 perp, bool isBuy, uint64 limitPx, uint64 sz);\\n    function sendIocOrder(uint16 perp, bool isBuy, uint64 limitPx, uint64 sz) external {\\n        emit IocOrder(msg.sender, perp, isBuy, limitPx, sz);\\n    }\\n}\\n\\n\\n**Limitations and Integration Patterns (The \\\"Catch\\\"):**\\n1.  **Lack of Full Atomicity:** Atomicity (transaction rollback on failure) is only partial. While event emission is atomic with the EVM transaction (event won't emit if EVM transaction reverts), the actual L1 action execution is *not* atomic with the EVM block. Events are signals for L1 to execute actions during its *next* execution, not within the EVM block context. This means an L1 action might fail (e.g., due to insufficient margin) even if the EVM transaction and event emission succeed. There is no way to get a response (success/failure or data) back to the EVM about the L1 action's execution. Also, updated L1 state due to an action will only be available in subsequent EVM blocks, not the same one. Actions are processed in the order events are raised, and one L1 action may fail while others succeed.\\n2.  **Message Sender vs. Transaction Origin:** Actions sent to L1 are executed in the context of `msg.sender` (the smart contract), not `tx.origin` (the user who initiated the EVM transaction). The smart contract itself performs the L1 action, necessitating careful design to ensure funds or positions can be managed or recovered by the contract.\\n3.  **Accounts Must Already Exist on L1:** A new smart contract's first L1 interaction will silently fail if its address doesn't already exist on L1. To resolve this, a dust amount of USDC must be manually sent to the smart contract's address on L1 (from any account) to create the L1 account.\\n4.  **Missing Transfer Edge Case (Token Transfers):** When tokens are sent from the EVM to L1 via an ERC20 transfer to the system address `0x2222222222222222222222222222222222222222`, the L1 spot balance is credited. However, the balance won't immediately reflect when calling `ERC20(...).balanceOf(...)` on the EVM or when reading L1 state in the same block. The balance enters a \"pre-crediting state,\" requiring protocols to internally track this if they need the total balance across both chains.\",\n    \"specifications\": {\n      \"precompile_read_address\": \"0x0000000000000000000000000000000000000800\",\n      \"l1_action_event_system_address\": \"0x3333333333333333333333333333333333333333\",\n      \"l1_token_transfer_system_address\": \"0x2222222222222222222222222222222222222222\",\n      \"solidity_pragma_version\": \"^0.8.0\"\n    },\n    \"pricing\": {},\n    \"features\": [\n      \"Native accessibility from HyperEVM to Hyperliquid L1\",\n      \"Smart contracts on HyperEVM can access perps and spot liquidity on Hyperliquid L1\",\n      \"Enables developers to build smart contracts with direct L1 market access\",\n      \"Facilitates creation of new DeFi primitives and on-chain strategies\",\n      \"HyperEVM is permissionless for smart contract deployment\"\n    ],\n    \"statistics\": {},\n    \"temporal_info\": {},\n    \"geographical_data\": {},\n    \"references\": [\n      \"Ambit Labs (Author of the guide)\",\n      \"Hyperliquid team (Source of compiled information)\",\n      \"Testnet (Proof of concept deployment)\"\n    ]\n  }\n}"}