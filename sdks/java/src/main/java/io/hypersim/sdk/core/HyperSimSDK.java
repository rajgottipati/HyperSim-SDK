package io.hypersim.sdk.core;

import io.hypersim.sdk.clients.HyperEVMClient;
import io.hypersim.sdk.clients.HyperCoreClient;
import io.hypersim.sdk.clients.WebSocketClient;
import io.hypersim.sdk.ai.AIAnalyzer;
import io.hypersim.sdk.plugins.PluginSystem;
import io.hypersim.sdk.types.*;
import io.hypersim.sdk.exceptions.*;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicLong;

/**\n * Main SDK class for HyperEVM transaction simulation.\n * \n * Provides comprehensive transaction simulation capabilities with:\n * - Real HyperEVM network integration\n * - Cross-layer HyperCore data access  \n * - AI-powered analysis and optimization\n * - WebSocket streaming for real-time data\n * - Plugin system for extensibility\n * - Project Loom virtual threads for high concurrency\n * - Production-ready error handling\n * \n * <p><b>Usage Example:</b>\n * <pre>{@code\n * var config = HyperSimConfig.builder()\n *     .network(Network.MAINNET)\n *     .aiEnabled(true)\n *     .openaiApiKey(\"your-api-key\")\n *     .build();\n * \n * try (var sdk = new HyperSimSDK(config)) {\n *     var transaction = TransactionRequest.createTransfer(\n *         \"0x1234...\", \"0x5678...\", \"1000000000000000000\");\n *     \n *     var result = sdk.simulate(transaction).join();\n *     System.out.println(\"Simulation success: \" + result.success());\n * }\n * }</pre>\n * \n * @author MiniMax Agent\n * @version 1.0.0\n * @since 1.0.0\n */\npublic class HyperSimSDK implements AutoCloseable {\n    \n    private static final Logger logger = LoggerFactory.getLogger(HyperSimSDK.class);\n    \n    private final HyperSimConfig config;\n    private final HyperEVMClient hyperEvmClient;\n    private final HyperCoreClient hyperCoreClient;\n    private final WebSocketClient wsClient;\n    private final PluginSystem pluginSystem;\n    private final AIAnalyzer aiAnalyzer;\n    private final ExecutorService virtualThreadExecutor;\n    private final AtomicLong requestCounter = new AtomicLong(0);\n    private final CompletableFuture<Void> initializationFuture;\n    \n    private volatile boolean isShutdown = false;\n    \n    /**\n     * Initialize HyperSim SDK with the specified configuration.\n     * \n     * @param config the SDK configuration\n     * @throws ConfigurationException if configuration is invalid\n     * @throws HyperSimException if initialization fails\n     */\n    public HyperSimSDK(@NotNull HyperSimConfig config) throws HyperSimException {\n        this.config = Objects.requireNonNull(config, \"Configuration cannot be null\");\n        \n        try {\n            // Create virtual thread executor for high concurrency\n            this.virtualThreadExecutor = Executors.newVirtualThreadPerTaskExecutor();\n            \n            // Initialize clients\n            this.hyperEvmClient = new HyperEVMClient(createEvmClientConfig());\n            this.hyperCoreClient = config.crossLayerEnabled() ? \n                new HyperCoreClient(createCoreClientConfig()) : null;\n            this.wsClient = config.streamingEnabled() ? \n                new WebSocketClient(createWsClientConfig()) : null;\n            \n            // Initialize plugin system\n            this.pluginSystem = new PluginSystem(createPluginSystemConfig());\n            \n            // Initialize AI analyzer if enabled\n            this.aiAnalyzer = config.aiEnabled() && config.openaiApiKey() != null ? \n                new AIAnalyzer(createAIAnalyzerConfig()) : null;\n            \n            // Initialize asynchronously\n            this.initializationFuture = initializeAsync();\n            \n            if (config.debug()) {\n                logger.info(\"HyperSim SDK initialized with config: network={}, aiEnabled={}, \" +\n                          \"crossLayerEnabled={}, streamingEnabled={}, pluginCount={}\",\n                          config.network(), config.aiEnabled(), config.crossLayerEnabled(),\n                          config.streamingEnabled(), config.plugins().size());\n            }\n            \n        } catch (Exception e) {\n            throw new HyperSimException(\"Failed to initialize HyperSim SDK\", e);\n        }\n    }\n    \n    /**\n     * Simulate a transaction on HyperEVM.\n     * \n     * This method uses virtual threads for high concurrency and includes\n     * comprehensive error handling with automatic retries.\n     * \n     * @param transaction the transaction to simulate\n     * @return a CompletableFuture containing the simulation result\n     * @throws ValidationException if the transaction is invalid\n     * @throws IllegalStateException if the SDK is shut down\n     */\n    @NotNull\n    public CompletableFuture<SimulationResult> simulate(@NotNull TransactionRequest transaction) {\n        Objects.requireNonNull(transaction, \"Transaction cannot be null\");\n        checkNotShutdown();\n        \n        return initializationFuture.thenCompose(v -> \n            CompletableFuture.supplyAsync(() -> {\n                String requestId = generateRequestId();\n                \n                try {\n                    if (config.debug()) {\n                        logger.debug(\"Starting simulation for transaction: {} (requestId={})\", \n                                   transaction, requestId);\n                    }\n                    \n                    // Execute before-simulation hooks\n                    pluginSystem.executeHooks(\"before-simulation\", requestId, transaction);\n                    \n                    // Perform simulation on HyperEVM\n                    SimulationResult result = hyperEvmClient.simulate(transaction);\n                    \n                    // Fetch cross-layer data if enabled\n                    if (hyperCoreClient != null && config.crossLayerEnabled()) {\n                        var hyperCoreData = hyperCoreClient.getRelevantData(transaction);\n                        result = SimulationResult.builder()\n                            .success(result.success())\n                            .gasUsed(result.gasUsed())\n                            .returnData(result.returnData())\n                            .error(result.error())\n                            .revertReason(result.revertReason())\n                            .blockType(result.blockType())\n                            .estimatedBlock(result.estimatedBlock())\n                            .trace(result.trace())\n                            .hyperCoreData(hyperCoreData)\n                            .stateChanges(result.stateChanges())\n                            .events(result.events())\n                            .timestamp(result.timestamp())\n                            .build();\n                    }\n                    \n                    // Execute after-simulation hooks\n                    pluginSystem.executeHooks(\"after-simulation\", requestId, result);\n                    \n                    if (config.debug()) {\n                        logger.debug(\"Simulation completed: success={}, gasUsed={} (requestId={})\", \n                                   result.success(), result.gasUsed(), requestId);\n                    }\n                    \n                    return result;\n                    \n                } catch (ValidationException e) {\n                    pluginSystem.executeHooks(\"on-error\", requestId, e);\n                    throw e;\n                } catch (Exception e) {\n                    pluginSystem.executeHooks(\"on-error\", requestId, e);\n                    throw new SimulationException(\"Simulation failed\", e);\n                }\n            }, virtualThreadExecutor)\n        );\n    }\n    \n    /**\n     * Get AI-powered insights for a simulation result.\n     * \n     * Requires AI to be enabled in the configuration.\n     * \n     * @param simulationResult the simulation result to analyze\n     * @return a CompletableFuture containing AI insights\n     * @throws ValidationException if AI is not enabled\n     * @throws IllegalStateException if the SDK is shut down\n     */\n    @NotNull\n    public CompletableFuture<AIInsights> getAIInsights(@NotNull SimulationResult simulationResult) {\n        Objects.requireNonNull(simulationResult, \"Simulation result cannot be null\");\n        checkNotShutdown();\n        \n        if (aiAnalyzer == null) {\n            return CompletableFuture.failedFuture(\n                new ValidationException(\"AI features not enabled. Initialize with aiEnabled=true and provide openaiApiKey\"));\n        }\n        \n        return initializationFuture.thenCompose(v -> \n            CompletableFuture.supplyAsync(() -> {\n                String requestId = generateRequestId();\n                \n                try {\n                    // Execute before-ai-analysis hooks\n                    pluginSystem.executeHooks(\"before-ai-analysis\", requestId, simulationResult);\n                    \n                    AIInsights insights = aiAnalyzer.analyzeSimulation(simulationResult);\n                    \n                    // Execute after-ai-analysis hooks\n                    pluginSystem.executeHooks(\"after-ai-analysis\", requestId, insights);\n                    \n                    return insights;\n                    \n                } catch (Exception e) {\n                    pluginSystem.executeHooks(\"on-error\", requestId, e);\n                    throw new SimulationException(\"AI analysis failed\", e);\n                }\n            }, virtualThreadExecutor)\n        );\n    }\n    \n    /**\n     * Optimize a bundle of transactions.\n     * \n     * Uses virtual threads to simulate all transactions concurrently,\n     * then applies AI-powered optimization if available.\n     * \n     * @param transactions the transactions to optimize\n     * @return a CompletableFuture containing bundle optimization results\n     * @throws ValidationException if the bundle is empty\n     * @throws IllegalStateException if the SDK is shut down\n     */\n    @NotNull\n    public CompletableFuture<BundleOptimization> optimizeBundle(@NotNull List<TransactionRequest> transactions) {\n        Objects.requireNonNull(transactions, \"Transactions cannot be null\");\n        checkNotShutdown();\n        \n        if (transactions.isEmpty()) {\n            return CompletableFuture.failedFuture(\n                new ValidationException(\"Transaction bundle cannot be empty\"));\n        }\n        \n        return initializationFuture.thenCompose(v -> {\n            // Simulate all transactions concurrently using virtual threads\n            List<CompletableFuture<SimulationResult>> simulationFutures = transactions.stream()\n                .map(this::simulate)\n                .toList();\n            \n            // Wait for all simulations to complete\n            return CompletableFuture.allOf(simulationFutures.toArray(new CompletableFuture[0]))\n                .thenCompose(ignored -> {\n                    List<SimulationResult> simulations = simulationFutures.stream()\n                        .map(CompletableFuture::join)\n                        .toList();\n                    \n                    // Optimize bundle with AI if available\n                    if (aiAnalyzer != null) {\n                        return CompletableFuture.supplyAsync(() -> \n                            aiAnalyzer.optimizeBundle(simulations), virtualThreadExecutor);\n                    } else {\n                        // Basic optimization without AI\n                        return CompletableFuture.completedFuture(basicBundleOptimization(simulations));\n                    }\n                });\n        });\n    }\n    \n    /**\n     * Assess risk level for a transaction.\n     * \n     * @param transaction the transaction to assess\n     * @return a CompletableFuture containing risk assessment\n     */\n    @NotNull\n    public CompletableFuture<RiskAssessment> assessRisk(@NotNull TransactionRequest transaction) {\n        Objects.requireNonNull(transaction, \"Transaction cannot be null\");\n        checkNotShutdown();\n        \n        return simulate(transaction).thenCompose(simulation -> {\n            if (aiAnalyzer != null) {\n                return getAIInsights(simulation).thenApply(insights -> \n                    new RiskAssessment(\n                        insights.riskLevel(),\n                        insights.securityWarnings() != null ? insights.securityWarnings() : List.of(),\n                        insights.confidenceScore()\n                    )\n                );\n            } else {\n                // Basic risk assessment without AI\n                return CompletableFuture.completedFuture(basicRiskAssessment(simulation));\n            }\n        });\n    }\n    \n    /**\n     * Get network status and health metrics.\n     * \n     * @return a CompletableFuture containing network status\n     */\n    @NotNull\n    public CompletableFuture<NetworkStatus> getNetworkStatus() {\n        checkNotShutdown();\n        \n        return initializationFuture.thenCompose(v -> \n            CompletableFuture.supplyAsync(() -> \n                hyperEvmClient.getNetworkStatus(), virtualThreadExecutor)\n        );\n    }\n    \n    /**\n     * Connect to WebSocket for real-time data.\n     * \n     * @return a CompletableFuture that completes when connected\n     * @throws ValidationException if WebSocket streaming is not enabled\n     */\n    @NotNull\n    public CompletableFuture<Void> connectWebSocket() {\n        checkNotShutdown();\n        \n        if (wsClient == null) {\n            return CompletableFuture.failedFuture(\n                new ValidationException(\"WebSocket streaming not enabled. Initialize with streamingEnabled=true\"));\n        }\n        \n        return initializationFuture.thenCompose(v -> wsClient.connect());\n    }\n    \n    /**\n     * Disconnect WebSocket.\n     */\n    public void disconnectWebSocket() {\n        if (wsClient != null) {\n            wsClient.disconnect();\n        }\n    }\n    \n    /**\n     * Check if WebSocket is connected.\n     * \n     * @return true if connected, false otherwise\n     */\n    public boolean isWebSocketConnected() {\n        return wsClient != null && wsClient.isConnected();\n    }\n    \n    /**\n     * Add a plugin at runtime.\n     * \n     * @param pluginConfig the plugin configuration\n     * @return a CompletableFuture that completes when the plugin is added\n     */\n    @NotNull\n    public CompletableFuture<Void> addPlugin(@NotNull HyperSimConfig.PluginConfig pluginConfig) {\n        Objects.requireNonNull(pluginConfig, \"Plugin config cannot be null\");\n        checkNotShutdown();\n        \n        return initializationFuture.thenCompose(v -> \n            CompletableFuture.runAsync(() -> \n                pluginSystem.registerPlugin(pluginConfig), virtualThreadExecutor)\n        );\n    }\n    \n    /**\n     * Remove a plugin.\n     * \n     * @param pluginName the name of the plugin to remove\n     * @return a CompletableFuture that completes when the plugin is removed\n     */\n    @NotNull\n    public CompletableFuture<Void> removePlugin(@NotNull String pluginName) {\n        Objects.requireNonNull(pluginName, \"Plugin name cannot be null\");\n        checkNotShutdown();\n        \n        return initializationFuture.thenCompose(v -> \n            CompletableFuture.runAsync(() -> \n                pluginSystem.unregisterPlugin(pluginName), virtualThreadExecutor)\n        );\n    }\n    \n    /**\n     * Get list of registered plugins.\n     * \n     * @return list of plugin information\n     */\n    @NotNull\n    public List<PluginInfo> getPlugins() {\n        return pluginSystem.getPlugins();\n    }\n    \n    /**\n     * Gets the current configuration.\n     * \n     * @return the SDK configuration\n     */\n    @NotNull\n    public HyperSimConfig getConfig() {\n        return config;\n    }\n    \n    /**\n     * Shutdown the SDK and cleanup resources.\n     * \n     * This method is automatically called when using try-with-resources.\n     */\n    @Override\n    public void close() {\n        if (isShutdown) {\n            return;\n        }\n        \n        isShutdown = true;\n        \n        try {\n            // Disconnect WebSocket\n            if (wsClient != null) {\n                wsClient.disconnect();\n            }\n            \n            // Shutdown plugin system\n            if (pluginSystem != null) {\n                pluginSystem.shutdown();\n            }\n            \n            // Shutdown clients\n            if (hyperEvmClient != null) {\n                hyperEvmClient.close();\n            }\n            \n            if (hyperCoreClient != null) {\n                hyperCoreClient.close();\n            }\n            \n            // Shutdown executor\n            if (virtualThreadExecutor != null) {\n                virtualThreadExecutor.shutdown();\n                try {\n                    if (!virtualThreadExecutor.awaitTermination(10, TimeUnit.SECONDS)) {\n                        virtualThreadExecutor.shutdownNow();\n                    }\n                } catch (InterruptedException e) {\n                    virtualThreadExecutor.shutdownNow();\n                    Thread.currentThread().interrupt();\n                }\n            }\n            \n            if (config.debug()) {\n                logger.info(\"HyperSim SDK shutdown complete\");\n            }\n            \n        } catch (Exception e) {\n            logger.warn(\"Error during SDK shutdown\", e);\n        }\n    }\n    \n    /**\n     * Initialize SDK components asynchronously.\n     */\n    private CompletableFuture<Void> initializeAsync() {\n        return CompletableFuture.runAsync(() -> {\n            try {\n                // Initialize plugin system\n                for (var pluginConfig : config.plugins()) {\n                    try {\n                        pluginSystem.registerPlugin(pluginConfig);\n                    } catch (Exception e) {\n                        logger.warn(\"Failed to register plugin '{}': {}\", pluginConfig.name(), e.getMessage());\n                    }\n                }\n                \n                pluginSystem.initialize();\n                \n                if (config.debug()) {\n                    logger.debug(\"SDK initialization completed\");\n                }\n                \n            } catch (Exception e) {\n                throw new RuntimeException(\"Failed to initialize SDK components\", e);\n            }\n        }, virtualThreadExecutor);\n    }\n    \n    private void checkNotShutdown() {\n        if (isShutdown) {\n            throw new IllegalStateException(\"SDK has been shut down\");\n        }\n    }\n    \n    private String generateRequestId() {\n        return \"req_\" + System.currentTimeMillis() + \"_\" + requestCounter.incrementAndGet();\n    }\n    \n    private BundleOptimization basicBundleOptimization(List<SimulationResult> simulations) {\n        long totalGas = simulations.stream()\n            .mapToLong(sim -> Long.parseLong(sim.gasUsed()))\n            .sum();\n        \n        return BundleOptimization.builder()\n            .originalGas(String.valueOf(totalGas))\n            .optimizedGas(String.valueOf(totalGas))\n            .gasSaved(\"0\")\n            .suggestions(List.of(\"Enable AI features for advanced bundle optimization\"))\n            .reorderedIndices(IntStream.range(0, simulations.size()).boxed().toList())\n            .build();\n    }\n    \n    private RiskAssessment basicRiskAssessment(SimulationResult simulation) {\n        List<String> factors = new ArrayList<>();\n        AIInsights.RiskLevel riskLevel = AIInsights.RiskLevel.LOW;\n        \n        if (!simulation.success()) {\n            factors.add(\"Transaction simulation failed\");\n            riskLevel = AIInsights.RiskLevel.HIGH;\n        }\n        \n        if (Long.parseLong(simulation.gasUsed()) > 1_000_000) {\n            factors.add(\"High gas usage detected\");\n            riskLevel = riskLevel == AIInsights.RiskLevel.HIGH ? AIInsights.RiskLevel.HIGH : AIInsights.RiskLevel.MEDIUM;\n        }\n        \n        return new RiskAssessment(riskLevel, factors, 0.5);\n    }\n    \n    // Configuration helper methods\n    private HyperEVMClient.Config createEvmClientConfig() {\n        return HyperEVMClient.Config.builder()\n            .network(config.network())\n            .rpcEndpoint(config.rpcEndpoint())\n            .timeout(config.timeout())\n            .debug(config.debug())\n            .connectionPool(config.connectionPool())\n            .retry(config.retry())\n            .build();\n    }\n    \n    private HyperCoreClient.Config createCoreClientConfig() {\n        return HyperCoreClient.Config.builder()\n            .network(config.network())\n            .debug(config.debug())\n            .build();\n    }\n    \n    private WebSocketClient.Config createWsClientConfig() {\n        return WebSocketClient.Config.builder()\n            .network(config.network())\n            .wsEndpoint(config.wsEndpoint())\n            .debug(config.debug())\n            .build();\n    }\n    \n    private PluginSystem.Config createPluginSystemConfig() {\n        return PluginSystem.Config.builder()\n            .debug(config.debug())\n            .metricsEnabled(config.metricsEnabled())\n            .build();\n    }\n    \n    private AIAnalyzer.Config createAIAnalyzerConfig() {\n        return AIAnalyzer.Config.builder()\n            .apiKey(config.openaiApiKey())\n            .debug(config.debug())\n            .build();\n    }\n    \n    /**\n     * Risk assessment result.\n     */\n    public record RiskAssessment(\n        @NotNull AIInsights.RiskLevel riskLevel,\n        @NotNull List<String> factors,\n        double confidence\n    ) {\n        public RiskAssessment {\n            Objects.requireNonNull(riskLevel, \"Risk level cannot be null\");\n            Objects.requireNonNull(factors, \"Factors cannot be null\");\n        }\n    }\n    \n    /**\n     * Plugin information.\n     */\n    public record PluginInfo(\n        @NotNull String name,\n        @NotNull String version,\n        boolean enabled\n    ) {\n        public PluginInfo {\n            Objects.requireNonNull(name, \"Name cannot be null\");\n            Objects.requireNonNull(version, \"Version cannot be null\");\n        }\n    }\n}\n